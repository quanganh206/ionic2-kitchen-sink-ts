// Generated by typings
// Source: node_modules/ng2-translate/src/translate.pipe.d.ts
declare module '~ng2-translate/src/translate.pipe' {
import { PipeTransform, EventEmitter, OnDestroy, ChangeDetectorRef } from 'angular2/core';
import { TranslateService, LangChangeEvent } from '~ng2-translate/src/translate.service';
export class TranslatePipe implements PipeTransform, OnDestroy {
    private translate;
    private _ref;
    value: string;
    lastKey: string;
    lastParams: any[];
    onLangChange: EventEmitter<LangChangeEvent>;
    constructor(translate: TranslateService, _ref: ChangeDetectorRef);
    /**
     * @name equals
     *
     * @description
     * Determines if two objects or two values are equivalent.
     *
     * Two objects or values are considered equivalent if at least one of the following is true:
     *
     * * Both objects or values pass `===` comparison.
     * * Both objects or values are of the same type and all of their properties are equal by
     *   comparing them with `equals`.
     *
     * @param {*} o1 Object or value to compare.
     * @param {*} o2 Object or value to compare.
     * @returns {boolean} True if arguments are equal.
     */
    private equals(o1, o2);
    updateValue(key: string, interpolateParams?: Object): void;
    transform(query: string, ...args: any[]): any;
    /**
     * Clean any existing subscription to onLangChange events
     * @private
     */
    _dispose(): void;
    ngOnDestroy(): void;
}
}
declare module 'ng2-translate/src/translate.pipe' {
export * from '~ng2-translate/src/translate.pipe';
}

// Generated by typings
// Source: node_modules/ng2-translate/src/translate.service.d.ts
declare module '~ng2-translate/src/translate.service' {
import { EventEmitter } from 'angular2/core';
import { Http } from 'angular2/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/share';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/merge';
import 'rxjs/add/operator/toArray';
export interface LangChangeEvent {
    lang: string;
    translations: any;
}
export abstract class MissingTranslationHandler {
    /**
     * A function that handles missing translations.
     * @param key the missing key
     * @returns {any} a value or an observable
     * If it returns a value, then this value is used.
     * If it return an observable, the value returned by this observable will be used (except if the method was "instant").
     * If it doesn't return then the key will be used as a value
     */
    abstract handle(key: string): any;
}
export abstract class TranslateLoader {
    abstract getTranslation(lang: string): Observable<any>;
}
export class TranslateStaticLoader implements TranslateLoader {
    private http;
    private prefix;
    private suffix;
    constructor(http: Http, prefix?: string, suffix?: string);
    /**
     * Gets the translations from the server
     * @param lang
     * @returns {any}
     */
    getTranslation(lang: string): Observable<any>;
}
export class TranslateService {
    private http;
    currentLoader: TranslateLoader;
    private missingTranslationHandler;
    /**
     * The lang currently used
     */
    currentLang: string;
    /**
     * An EventEmitter to listen to lang changes events
     * onLangChange.subscribe((params: LangChangeEvent) => {
     *     // do something
     * });
     * @type {ng.EventEmitter<LangChangeEvent>}
     */
    onLangChange: EventEmitter<LangChangeEvent>;
    private pending;
    private translations;
    private defaultLang;
    private langs;
    private parser;
    /**
     *
     * @param http The Angular 2 http provider
     * @param currentLoader An instance of the loader currently used
     * @param missingTranslationHandler A handler for missing translations.
     */
    constructor(http: Http, currentLoader: TranslateLoader, missingTranslationHandler: MissingTranslationHandler);
    /**
     * Sets the default language to use as a fallback
     * @param lang
     */
    setDefaultLang(lang: string): void;
    /**
     * Changes the lang currently used
     * @param lang
     * @returns {Observable<*>}
     */
    use(lang: string): Observable<any>;
    /**
     * Gets an object of translations for a given language with the current loader
     * @param lang
     * @returns {Observable<*>}
     */
    getTranslation(lang: string): Observable<any>;
    /**
     * Manually sets an object of translations for a given language
     * @param lang
     * @param translations
     */
    setTranslation(lang: string, translations: Object): void;
    /**
     * Returns an array of currently available langs
     * @returns {any}
     */
    getLangs(): Array<string>;
    /**
     * Update the list of available langs
     */
    private updateLangs();
    /**
     * Returns the parsed result of the translations
     * @param translations
     * @param key
     * @param interpolateParams
     * @returns {any}
     */
    private getParsedResult(translations, key, interpolateParams?);
    /**
     * Gets the translated value of a key (or an array of keys)
     * @param key
     * @param interpolateParams
     * @returns {any} the translated key, or an object of translated keys
     */
    get(key: string | Array<string>, interpolateParams?: Object): Observable<string | any>;
    /**
     * Returns a translation instantly from the internal state of loaded translation.
     * All rules regarding the current language, the preferred language of even fallback languages will be used except any promise handling.
     * @param key
     * @param interpolateParams
     * @returns {string}
     */
    instant(key: string | Array<string>, interpolateParams?: Object): string | any;
    /**
     * Sets the translated value of a key
     * @param key
     * @param value
     * @param lang
     */
    set(key: string, value: string, lang?: string): void;
    /**
     * Changes the current lang
     * @param lang
     */
    private changeLang(lang);
    /**
     * Allows to reload the lang file from the file
     * @param lang
     * @returns {Observable<any>}
     */
    reloadLang(lang: string): Observable<any>;
    /**
     * Deletes inner translation
     * @param lang
     */
    resetLang(lang: string): void;
}
}
declare module 'ng2-translate/src/translate.service' {
export * from '~ng2-translate/src/translate.service';
}

// Generated by typings
// Source: node_modules/ng2-translate/src/translate.parser.d.ts
declare module '~ng2-translate/src/translate.parser' {
export class Parser {
    templateMatcher: RegExp;
    /**
     * Interpolates a string to replace parameters
     * "This is a {{ key }}" ==> "This is a value", with params = { key: "value" }
     * @param expr
     * @param params
     * @returns {string}
     */
    interpolate(expr: string, params?: any): string;
    /**
     * Gets a value from an object by composed key
     * parser.getValue({ key1: { keyA: 'valueI' }}, 'key1.keyA') ==> 'valueI'
     * @param target
     * @param key
     * @returns {string}
     */
    getValue(target: any, key: string): string;
}
}
declare module 'ng2-translate/src/translate.parser' {
export * from '~ng2-translate/src/translate.parser';
}

// Generated by typings
// Source: node_modules/ng2-translate/ng2-translate.d.ts
declare module 'ng2-translate' {
import { TranslatePipe } from '~ng2-translate/src/translate.pipe';
import { TranslateService } from '~ng2-translate/src/translate.service';
export * from '~ng2-translate/src/translate.pipe';
export * from '~ng2-translate/src/translate.service';
export * from '~ng2-translate/src/translate.parser';
export const TRANSLATE_PROVIDERS: any;
var _default: {
    pipes: typeof TranslatePipe[];
    providers: typeof TranslateService[];
};
export default _default;
}
